;;; preprosessor
%define	BytePerSec	0x0200
%define	SecPerClus	0x10
%define	RsvdSecCnt	0x0020
%define	NumFATs		0x02
%define	RootEntCnt	0x0000
%define	SecPerTrk	0x0020
%define NumHeads	0x0040
%define	HiddenSec	0x00000800
%define	TotSec		0x00800000
%define	SecPerFat	0x00001000	; 4096
%xdefine TotTracks	TotSec / SecPerTrk ; 0x40000
%xdefine BytePerTrk	BytePerSec * SecPerTrk
%define	HardDiskFlag	0x80	; if hard disk, 0x80 else 0x00

;;; bootloader
[BITS 16]
	ORG	0x7c00

;;; Boot Sector field
	jmp	BS_BootCode32	; jump to bootstrap code
	nop			; padding nop to fill field

BS_OEMName	db	"MYOS32  "

;;; BIOS Parameter Block for FAT32
BPB_BytePerSec	dw	BytePerSec	; Byte per Sector
BPB_SecPerClus	db	SecPerClus	; Sector per Cluster, Cluster is an allocation unit.
BPB_RsvdSecCnt	dw	RsvdSecCnt	; Reserved Sector Count, least 1
BPB_NumFATs	db	NumFATs		; Num of FATS, one is for duplication
BPB_RootEntCnt	dw	RootEntCnt	; Num of entry in root in FAT12/16. In FAT32, should be 0
BPB_TotSec16	dw	0x0000		; All sectors in the volume. In FAT32, should be 0
BPB_Media	db	0xf8		; Legacy field, unused but
BPB_FATSz16	dw	0x0000		; Use in FAT12/16, should be 0 in FAT32. can define this is FAT12/16 or FAT32 by this.
BPB_SecPerTrk	dw	SecPerTrk	; Sectors per Track. related to a storage that use geometery, used in IBM PC's disk BIOS
;;; Number of head. related to a storage that use geometery, used in IBM PC's disk BIOS
BPB_NumHeads	dw	NumHeads
;;; Number of hidden sectors before this volume. depends on system. Only for IBM PC disk BIOS
BPB_HiddSec	dd	HiddenSec
BPB_TotSec32	dd	TotSec		; Total Sectors without hidden sectors. change 0x01ca3800 => 4GB
BPB_FATz32	dd	SecPerFat	; Sector per FAT. FAT Area size is BPB_NUMFATs * this.
BPB_ExtFlags	dw	0x0000		; Flags but i don't know that mean
BPB_FSVer	dw	0x0000		; Version of FAT32. Don't use newer version
BPB_RootClus	dd	0x00000002	; Top Cluster number of root directory. 2 is top cluster
BPB_FSInfo	dw	0x0001	   ; In reserved area, sector number of FSINFO struct. always be 1
BPB_BkBootSec	dw	0x0006	   ; Sector of boot-sector's backup. usualy 6
BPB_Reserved1	dd	0x00000000 ; Reserved field, should be 0
BPB_Reserved2	dd	0x00000000
BPB_Reserved3	dd	0x00000000
;;; Boot Sector
BS_DrvNum	db	0x80	; drive num, used in disk BIOS. in fact, depends on system
BS_Rserved1	db	0x00	; Reserved, should be 0
BS_BootSig	db	0x29	; extended boot signature, 0x29. this means later 3 fields exists
BS_VolID	dd	0xd02405e2    ; Serial number of volume. generated by time when this volume was generated.
BS_VolLab	db	"BOOT VALUME" ; Valume label
BS_FilSysType	db	"FAT32   " ; always FAT32 and unused

;;; program in here
BS_BootCode32:
	cli			; inhibit interrupt
	;; initialize
	xor	ax, ax
	xor	bx, bx
	xor	cx, cx
	xor	dx, dx
	mov	ds, ax
	mov	es, ax
	mov	fs, ax
	mov	gs, ax
	mov	ss, ax
	mov	sp, 0xfffc

	mov	si, HELLO
	call	DisplayMessage
	call	InitDrive

	mov	bx, 0x0820
	mov	es,	bx
	xor	bx,	bx
	mov	cl,	0x10
	mov	ax,	0x4018
	call ReadSectors

	jmp	0x40e000

	;; Change screen mode
	mov	al, 0x13				; VGA Graphics, 320x200x8bit
	mov	ah, 0x00
	int	0x10

	mov	si, BOOT_END_MSG
	call DisplayMessage

	hlt

HELLO	db	"Hello, world!",0x0d,0x0a,0x00
BOOT_END_MSG		db	"BOOT END!!",0x0d,0x0a,0x00
DEBUG	db	"SUCCESS",0x0d,0x0a,0x00

DisplayMessage:
	push	ax
	push	bx
StartDispMsg:
	lodsb			; al <= ds:si, si++
	test	al, al
	jz	.DONE
	mov	ah, 0x0e
	mov	bh, 0x00
	mov	bl, 0x07
	int	0x10
	jmp	StartDispMsg
.DONE:
	pop	bx
	pop	ax
	ret

;;; Initialize Storage
InitDrive:
	pusha

	xor	ax, ax
	mov	dx, ax
	or	dl,	0x80
	int	0x13		; BIOS interrupt: Disk Services
	jc	InitDrive_Error

	mov	dl,	0x80
	call DiskInfo

	popa
	ret
InitDrive_Error:
	mov	si, InitDrvErrMsg
	call	DisplayMessage
	hlt
InitDrvErrMsg	db	"InitDrive Error", 0x0d,0x0a,0x00

;;; Read Sector by Tracks from drive
;;; ax:	track number
;;; bx:	address to read tracks
;;; es:	base address to read tracks
;;; cx:	the number of tracks to read
;;;
;;; WARN: Only word range!
ReadTracks:
	pusha

	mov	di,	cx
	;; TODO: check max Track num
	;; convert track num to sector num
	mov	dx, [BPB_SecPerTrk]
	mul	dx

	;; Read trucsk by one
	mov	cl,	[BPB_SecPerTrk]
	xor	si,	si					; for counter
ReadTracks_Loop:
	cmp	si,	di
	je	ReadTracks_LoopEnd
	call	ReadSectors
	inc	si
	add	bx,	BytePerTrk
ReadTracks_LoopEnd:
	popa
	ret

;;; Read Sector from drive
;;; args
;;; ax: sector number
;;; bx: address to read sectors
;;; es: base address to read sectors
;;; cl: the number of sector to read
ReadSectors:
	pusha

	call LBA2CHS4HD

	mov	ah, 0x02		; read sector mode
	mov	al, cl		; num of sector to read

	;; cx[5:0]: sector index
	;; cx[7:6][15:8]: track index
	xor dx,	dx
	mov	cx, [physicalTrack]
	mov	dx,	cx
	and	dx,	0x0300				; set upper	2 bits to [7:6]
	shr	dx,	0x02
	shl	cx,	0x08				; [15:8] = track[7:0]
	add	cx,	dx					; [15:6] = track[7:0][10:8]
	xor	dx,	dx
	mov	dl, [physicalSector]
	add	cx,	dx	; [5:0] = sector num

	mov	dh, [physicalHead]
	mov	dl, 0x80				; use first hard disk

	int	0x13
	;; error check
	jc	ReadSecErr
	popa
	ret
ReadSecErr:
	mov	si, ReadSecErrMsg
	call	DisplayMessage
	hlt
ReadSecErrMsg	db	"ReadSectorsError",0x00
	ret

;;; LBA2CHS4HD
;;; should call DISKINFO before call this
;;;
;;; input AX:sector number(LBA)
;;; output AX:quotient, DX:Remainder
;;; convert physical address to logical address
;;; physical sector = (logical sector MOD sectors per track) + 1
;;; physical head   = (logical sector / sectors per track) MOD number of heads
;;; physical track  = logical sector / (sectors per track * number of heads)
LBA2CHS4HD:
	pusha

	xor	dx, dx
	div	word [DSecPerHead] ; ax <= ax / arg, dx <= ax % arg
	inc dl
	mov byte [physicalSector], dl

	xor	dx,	dx
	mov	bx,	dx
	mov	bl,	[DHeadPerTrack]
	div	word bx
	mov	byte [physicalHead], dl
	mov	word [physicalTrack], ax

	popa
	ret
;;; for LBA2CHS and LBA2CHS4HD
physicalSector	db	0x00
physicalHead	db	0x00
physicalTrack	dw	0x0000

;;; Get disk info, for hard disk
;;; dl:	drive index
;;; WARN: ES:DI may have to be 0 at some BIOS
DiskInfo:
	pusha

	mov	ah,	0x08
	int	0x13
	jc	DISKINFOERR

	mov	[DDiskNum],	dl
	;; dh has last index of heads and that is 0-indexed
	inc dh
	mov	[DHeadPerTrack],	dh
	mov	dx,	cx
	and	cx,	0x3f				; get lower 6-bits
	mov	[DSecPerHead], cx
	;; get upper 8 bits and 7-6 bits, [7:6][15:8] is last index of track
	mov	cx, dx
	shr cx, 8
	and	dx,	0x00c0
	shl dx, 2
	add	cx, dx
	add	cx, 1
	mov [DTrackPerDisk], cx

	popa
	ret
DISKINFOERR:
	mov	si, DiskInfoErrMsg
	call DisplayMessage
	hlt
DDiskNum	db	0x00
DHeadPerTrack	db	0x00
DTrackPerDisk	dw	0x0000
DSecPerHead	db	0x00
DiskInfoErrMsg	db	"DiskInfoError",0x0d,0x0a,0x00

;;; padding
TIMES 510 - ($ - $$) DB 0

BS_BootSign	dw	0xaa55

;;; FSInfo of FAT32. pointed by BPB_FSInfo
FSI_LeadSig	dd	0x41615252		; Signature for FSInfo
TIMES	480	db 0				; reserved area
FSI_StructSig	dd	0x61417272	; Signature for FSInfo
FSI_Free_Count	dd	0x0007fdfd	; num of free cluster, 0xffffffff means this field is unavailable
FSI_Nxt_Free	dd	0x00000002	; last allocated cluster number, 0xffffffff means unavailable
TIMES	12	db	0				; reserved area
FSI_TrailSig	dd	0xaa550000	; Signature for FSInfo tail
;;; If sector size is larger than 512, needs padding to fill sector

;;; Backup of FSInfo of FAT32. pointed by BPB_BkBootSec
;;; Not use now!

;;; rest should be filled by 0
