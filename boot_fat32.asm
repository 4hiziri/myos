;;; preprosessor
%define	BytePerSec	0x0200
%define	SecPerClus	0x10
%define	RsvdSecCnt	0x0020
%define	NumFATs		0x02
%define	RootEntCnt	0x0000
%define	SecPerTrk	0x0020
%define NumHeads	0x0040
%define	HiddenSec	0x00000800
%define	TotSec		0x00800000
%define	SecPerFat	0x00001000	; 4096

;;; bootloader
[BITS 16]
	ORG	0x7c00

;;; Boot Sector field
	jmp	BS_BootCode32	; jump to bootstrap code
	nop			; padding nop to fill field
BS_OEMName	db	"MYOS32  "

;;; BIOS Parameter Block for FAT32
BPB_BytePerSec	dw	BytePerSec	; Byte per Sector
BPB_SecPerClus	db	SecPerClus	; Sector per Cluster, Cluster is an allocation unit.
BPB_RsvdSecCnt	dw	RsvdSecCnt	; Reserved Sector Count, least 1
BPB_NumFATs	db	NumFATs		; Num of FATS, one is for duplication
BPB_RootEntCnt	dw	RootEntCnt	; Num of entry in root in FAT12/16. In FAT32, should be 0
BPB_TotSec16	dw	0x0000		; All sectors in the volume. In FAT32, should be 0
BPB_Media	db	0xf8		; Legacy field, unused but
BPB_FATSz16	dw	0x0000		; Use in FAT12/16, should be 0 in FAT32. can define this is FAT12/16 or FAT32 by this.
BPB_SecPerTrk	dw	SecPerTrk	; Sectors per Truck. related to a storage that use geometery, used in IBM PC's disk BIOS
;;; Number of head. related to a storage that use geometery, used in IBM PC's disk BIOS
BPB_NumHeads	dw	NumHeads
;;; Number of hidden sectors before this volume. depends on system. Only for IBM PC disk BIOS
BPB_HiddSec	dd	HiddenSec
BPB_TotSec32	dd	TotSec		; Total Sectors without hidden sectors. change 0x01ca3800 => 4GB
BPB_FATz32	dd	SecPerFat	; Sector per FAT. FAT Area size is BPB_NUMFATs * this.
BPB_ExtFlags	dw	0x0000		; Flags but i don't know that mean
BPB_FSVer	dw	0x0000		; Version of FAT32. Don't use newer version
BPB_RootClus	dd	0x00000002	; Top Cluster number of root directory. 2 is top cluster
BPB_FSInfo	dw	0x0001	   ; In reserved area, sector number of FSINFO struct. always be 1
BPB_BkBootSec	dw	0x0006	   ; Sector of boot-sector's backup. usualy 6
BPB_Reserved1	dd	0x00000000 ; Reserved field, should be 0
BPB_Reserved2	dd	0x00000000
BPB_Reserved3	dd	0x00000000
;;; Boot Sector
BS_DrvNum	db	0x80	; drive num, used in disk BIOS. in fact, depends on system
BS_Rserved1	db	0x00	; Reserved, should be 0
BS_BootSig	db	0x29	; extended boot signature, 0x29. this means later 3 fields exists
BS_VolID	dd	0xd02405e2    ; Serial number of volume. generated by time when this volume was generated.
BS_VolLab	db	"BOOT VALUME" ; Valume label
BS_FilSysType	db	"FAT32   " ; always FAT32 and unused

;;; program in here
BS_BootCode32:
	cli			; inhibit interrupt
	;; initialize
	xor	ax, ax
	xor	bx, bx
	xor	cx, cx
	xor	dx, dx
	mov	ds, ax
	mov	es, ax
	mov	fs, ax
	mov	gs, ax
	mov	ss, ax
	mov	sp, 0xfffc

	mov	si, HELLO
	call	DisplayMessage

	call	InitDrive

	mov	ax, 0x1000	; sector number of first sectors to read
	mov	bx, 0x1000
	mov	es, bx		; base address
	mov	bx, 0x0000	; addr
	mov	cl, 0x00	; number of sectors to read
	call	ReadSectors

	hlt

HELLO	db	"Hello, world!",0x00

;;; for test, display message
DisplayMessage:
	push	ax
	push	bx
StartDispMsg:
	lodsb			; al <= ds:si, si++
	test	al, al
	jz	.DONE
	mov	ah, 0x0e
	mov	bh, 0x00
	mov	bl, 0x07
	int	0x10
	jmp	StartDispMsg
.DONE:
	pop	bx
	pop	ax
	ret

;;; Initialize Storage
InitDrive:
	push	ax
	push	dx
	xor	ax, ax
	mov	dx, ax
	int	0x13		; BIOS interrupt: Disk Services
	jc	InitDrive_Error
	ret
InitDrive_Error:
	mov	si, InitDrvErrMsg
	call	DisplayMessage
	hlt
InitDrvErrMsg	db	"InitDrive Error", 0x00

;;; Read Sector from drive
;;; args
;;; ax: sector number
;;; bx: address to write sectors
;;; es: base address to write sectors
;;; cl: the number of sector to read
ReadSectors:
	;; prologue
	push	dx

	call	LBA2CHS
	mov	ah, 0x02		; read sector mode
	mov	al, cl			; num of sector to read
	mov	ch, [physicalTrack]	; under 1 byte of truck number
	mov	cl, [physicalSector]	; sector number
	mov	dh, [physicalHead]	; header num
	mov	dl, 0x00		; drive num
	int	0x13
	;; error check
	jc	ReadSecErr

	;; epilogue
	pop	dx
	ret
ReadSecErr:
	mov	si, ReadSecErrMsg
	call	DisplayMessage
	hlt
ReadSecErrMsg	db	"ReadSectorsError",0x00

;;;
;;; LBA2CHS
;;; input AX:sector number(LBA)
;;; output AX:quotient, DX:Remainder
;;; convert physical address to logical address
;;; physical sector = (logical sector MOD sectors per track) + 1
;;; physical head   = (logical sector / sectors per track) MOD number of heads
;;; physical track  = logical sector / (sectors per track * number of heads)
LBA2CHS:
	push	ax
	push	dx
	xor	dx, dx
	div	word [BPB_SecPerTrk] ; ax <= ax / arg, dx <= ax % arg
	inc	dl
	mov	byte [physicalSector], dl
	xor	dx, dx
	div	word [BPB_NumHeads]
	mov	byte [physicalHead], dl
	mov	byte [physicalTrack], al
	pop	dx
	pop	ax
	ret
physicalSector	db	0x00
physicalHead	db	0x00
physicalTrack	db	0x00

;;; padding
TIMES 510 - ($ - $$) DB 0

BS_BootSign	dw	0xaa55

;;; FSInfo of FAT32. pointed by BPB_FSInfo
FSI_LeadSig	dd	0x41615252		; Signature for FSInfo
TIMES	480	db 0				; reserved area
FSI_StructSig	dd	0x61417272	; Signature for FSInfo
FSI_Free_Count	dd	0x0007fdfd	; num of free cluster, 0xffffffff means this field is unavailable
FSI_Nxt_Free	dd	0x00000002	; last allocated cluster number, 0xffffffff means unavailable
TIMES	12	db	0				; reserved area
FSI_TrailSig	dd	0xaa550000	; Signature for FSInfo tail
;;; If sector size is larger than 512, needs padding to fill sector

;;; padding 4 sectors, until [5]
;;; TIMES	0x200 * 4	db	0
	
;;; Backup of FSInfo of FAT32. pointed by BPB_BkBootSec
;;; Not use now!

;;; rest should be filled by 0
